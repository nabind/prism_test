package com.ctb.prism.login.security.encoder;

import groovy.util.logging.Slf4j;

import java.io.UnsupportedEncodingException;
import java.security.NoSuchAlgorithmException;

import javax.crypto.Mac;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.encoding.PasswordEncoder;
import org.springframework.util.StringUtils;

import com.ctb.prism.core.util.SaltedPasswordEncoder;

@Slf4j
public class HMacShaEncoder implements PasswordEncoder {

    private static final int DEFAULT_ENCRYPTION_STRENGTH = 128;
    private static final String ENCODING_FOR_ENCRYPTION = "UTF-8";

    private boolean encodeHashAsBas64 = false;
    private String algorithm;
    private int strength;
    
    @Autowired
    SaltedPasswordEncoder encoder;

    /**
     * Initializes the ShaPasswordEncoder for SHA-1 strength
     */
    public HMacShaEncoder() {
        this(DEFAULT_ENCRYPTION_STRENGTH);
    }

    /**
     * Initialize the ShaPasswordEncoder with a given SHA stength as supported by the JVM
     * EX: <code>HMacShaPasswordEncoder encoder = new HMacShaPasswordEncoder(256);</code> initializes with SHA-256
     *
     * @param strength EX: 1, 256, 384, 512
     */
    public HMacShaEncoder(int strength) {
        this(strength, false);
        this.strength = strength;
    }

    public HMacShaEncoder(int strength, boolean encodeHashAsBase64) {
        this("HmacSHA" + String.valueOf(strength), encodeHashAsBase64);
        this.strength = strength;
    }

    public HMacShaEncoder(String algorithm, boolean encodeHashAsBase64) {
        this.algorithm = algorithm;
        setEncodeHashAsBas64(encodeHashAsBase64);
        //validity Check
        getMac();

    }

     protected final Mac getMac() throws IllegalArgumentException {
        try {
            return Mac.getInstance(algorithm);
        } catch (NoSuchAlgorithmException e) {
            throw new IllegalArgumentException("No such algorithm [" + algorithm + "]");
        }
    }

     /**
      * encode user password to match with database stored password
      * Note: the value of strength must match with <code>SaltedPasswordEncoder</code>'s strength value
      */
    public String encodePassword(String rawDataToBeEncrypted, Object salt) {
    	
    	return encoder.encryptPassword(rawDataToBeEncrypted, (String) salt, strength);
    	
        /*byte[] hmacData = null;
        if(rawDataToBeEncrypted != null){
        try {
            SecretKeySpec secretKey = new SecretKeySpec(rawDataToBeEncrypted.getBytes(ENCODING_FOR_ENCRYPTION), this.algorithm);
            System.out.println("--->"+secretKey);
            Mac mac = getMac();
            mac.init(secretKey);
            hmacData = mac.doFinal(salt.toString().getBytes(ENCODING_FOR_ENCRYPTION));

            if (isEncodeHashAsBas64()) {
                return new String(Base64.encode(hmacData), ENCODING_FOR_ENCRYPTION);
            } else {
                return new String(hmacData, ENCODING_FOR_ENCRYPTION);
            }

        }
        catch(InvalidKeyException ike){
            throw new RuntimeException("Invalid Key while encrypting.", ike);
        }
        catch (UnsupportedEncodingException e) {
            throw new RuntimeException("Unsupported Encoding while encrypting.",e);
        }
        }
        return "";*/
    	

    }

   /**
    * Validates a specified "raw" password against an encoded password. 
    * The encoded password should have previously been generated by encodePassword(String, Object). This method will encode the rawPass (using the optional salt), and then compared it with the presented encPass. 
    * For a discussion of salts, please refer to encodePassword(String, Object).
    * 
    * encPass - a pre-encoded password
    * rawPass - a raw password to encode and compare against the pre-encoded password
    * salt - optionally used by the implementation to "salt" the raw password before encoding. A null value is legal.
    */
    public boolean isPasswordValid(String encPass, String rawPass, Object salt) {
        if(!StringUtils.hasText(encPass) || !StringUtils.hasText(rawPass))
        {
            return false;
        }
        String pass1 = "" + encPass;
        String pass2 = encodePassword(rawPass, salt);
        
        //logger.info("pass1 = {}"+ pass1);
        //logger.info("pass2 = {}"+ pass2);
        
        return equals(pass1, pass2);
    }


    public boolean isEncodeHashAsBas64() {
        return encodeHashAsBas64;
    }

    public void setEncodeHashAsBas64(boolean encodeHashAsBas64) {
        this.encodeHashAsBas64 = encodeHashAsBas64;
    }


    private static boolean equals(String expected, String actual) {
        byte[] expectedBytes = null;
        byte[] actualBytes = null;
        try {
            expectedBytes = expected.getBytes(ENCODING_FOR_ENCRYPTION);
            actualBytes = actual.getBytes(ENCODING_FOR_ENCRYPTION);
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException("Unsupported Encoding while encrypting.",e);
        }

        int expectedLength = expectedBytes == null ? -1 : expectedBytes.length;
        int actualLength = actualBytes == null ? -1 : actualBytes.length;
        if (expectedLength != actualLength) {
            return false;
        }

        int result = 0;
        for (int i = 0; i < expectedLength; i++) {
            result |= expectedBytes[i] ^ actualBytes[i];
        }
        return result == 0;
    }
    
    
    public static void main(String[] args) {
    	HMacShaEncoder encoder = new HMacShaEncoder(256);
    	encoder.setEncodeHashAsBas64(true);
    	System.out.println(encoder.encodePassword("Passwd12", "ctbadminJkmqbrbaccesfejrtay9"));
	}
}