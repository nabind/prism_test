head	1.1;
access;
symbols
	ACSI_Prod_Version_012013:1.1.0.4
	Root_ACSI_Prod_Version_012013:1.1
	PROD_RELEASE_08MAR2013:1.1
	PhaseII:1.1.0.2
	Root_PhaseII:1.1;
locks; strict;
comment	@# @;


1.1
date	2013.04.17.11.02.30;	author dhara;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Production Version - Phase 2
@
text
@package com.ctb.prism.core.util;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;

import com.ctb.prism.core.constant.IApplicationConstants;
import com.ctb.prism.core.constant.IApplicationConstants.ROLE_TYPE;
import com.ctb.prism.core.constant.IApplicationConstants.USER_TYPE;
import com.ctb.prism.core.logger.IAppLogger;
import com.ctb.prism.core.logger.LogFactory;

/**
 * This class contains application specific utility methods.
 * This class is not meant to be sub-classed. All the methods declared in this class are static.
 */
public final class Utils
{
	private static final IAppLogger logger = LogFactory.getLoggerInstance(Utils.class.getName());

	/**
	 * Validates whether the roleName is a valid role or not. Returns true if the roleName is valid, false otherwise.
	 */
	public static boolean isValidRole( String roleName )
	{
		USER_TYPE[] userTypes = IApplicationConstants.USER_TYPE.values();
		for (USER_TYPE userType : userTypes) {
			if( userType.toString().equals(roleName))
			{
				return true;
			}
		}
		return false;
	}
	
	/**
	 * Validates whether the roleName is a valid role or not. Returns true if the roleName is valid, false otherwise.
	 */
	public static boolean isValidRoles( String roleName )
	{
		ROLE_TYPE[] userTypes = IApplicationConstants.ROLE_TYPE.values();
		for (ROLE_TYPE userType : userTypes) {
			if( userType.toString().equals(roleName))
			{
				return true;
			}
		}
		return false;
	}
	
	/**
	 * Returns the user role corresponding to the role name. In case the role is not found null is returned.
	 * @@param roleName
	 * @@return {@@link USER_TYPE}
	 */
	public static IApplicationConstants.USER_TYPE getRole( String roleName )
	{
		USER_TYPE[] userTypes = IApplicationConstants.USER_TYPE.values();
		for (USER_TYPE userType : userTypes) {
			if( userType.toString().equals(roleName))
			{
				return userType;
			}
		}
		return null;
	}


	/**
	 * Returns the user role corresponding to the role name. In case the role is not found null is returned.
	 * @@param roleName
	 * @@return {@@link USER_TYPE}
	 */
	public static IApplicationConstants.ROLE_TYPE getRoles( String roleName )
	{
		ROLE_TYPE[] roleTypes = IApplicationConstants.ROLE_TYPE.values();
		for (ROLE_TYPE userType : roleTypes) {
			if( userType.toString().equals(roleName))
			{
				return userType;
			}
		}
		return null;
	}
	
	/**
	 * Checks if password confirms CTB's password policy
	 * @@param passwd
	 * @@return
	 */
	public static boolean validatePassword(String passwd) {
		//String pattern ="^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[@@#$%^&+=])(?=\\S+$).{8,}$";
	    String pattern ="^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=\\S+$).{8,}$";
	    /**
	      	 ^                # start-of-string
			(?=.*[0-9])       # a digit must occur at least once
			(?=.*[a-z])       # a lower case letter must occur at least once
			(?=.*[A-Z])       # an upper case letter must occur at least once
			(?=.*[@@#$%^&+=])  # a special character must occur at least once
			(?=\S+$)          # no whitespace allowed in the entire string
			.{8,}             # anything, at least eight places though
			$                 # end-of-string
	     */
	    
	    return(passwd.matches(pattern));
	}
	
	/**
	 * This parameter is used to locate static PDF saved location
	 */
	private String acsiPdfLocation = "/mnt/ACSIREPORTS/dev/";
	
	public String getAcsiPdfLocation() {
		return acsiPdfLocation;
	}
	public void setAcsiPdfLocation(String acsiPdfLocation) {
		// this property is set from dispatcher-servlet.xml (<!-- Set PDF location -->) through setter injection
		this.acsiPdfLocation = acsiPdfLocation;
	}
	
	/**
	 * Create file from a inputStream
	 * @@param inputStream
	 * @@param fileName
	 * @@throws IOException 
	 */
	public static File convertInputStreamToFile(InputStream inputStream, String fileName) throws IOException {
		OutputStream out = null;
		File file = null;
		try {
			file = new File(fileName);
			// write the inputStream to a FileOutputStream
			out = new FileOutputStream(file);

			int read = 0;
			byte[] bytes = new byte[1024];

			while ((read = inputStream.read(bytes)) != -1) {
				out.write(bytes, 0, read);
			}
			logger.log(IAppLogger.DEBUG, "File created ... ");
		} catch (IOException e) {
			logger.log(IAppLogger.ERROR, e.getMessage());
		} finally {
			if(inputStream != null) inputStream.close();
			if(out != null) {
				out.flush();
				out.close();
			}
		}
		return file;
	}
	
	/**
	 * Create String from a inputStream
	 * @@param inputStream
	 * @@throws IOException 
	 */
	public static String convertInputStreamToString(InputStream inputStream) throws IOException {	
    	//read it with BufferedReader
    	BufferedReader br = new BufferedReader(new InputStreamReader(inputStream));
    	StringBuilder sb = new StringBuilder();
    	String line;
    	while ((line = br.readLine()) != null) {
    		sb.append(line);
    	} 
    	//logger.log(IAppLogger.DEBUG, sb.toString());
    	br.close();
    	return sb.toString();
    }
	
	/**
	 * Utility method to convert InputStream to byte[]
	 * @@param file
	 * @@return
	 */
	public static byte[] getFileDataFromInputStream(InputStream inputStream) {
		byte[] fileData = null;
		int i = 0;
		java.io.ByteArrayOutputStream baos = new java.io.ByteArrayOutputStream();
		try {
			while ((i = inputStream.read()) != -1) {
				baos.write(i);
			}
			fileData = baos.toByteArray();
		} catch (java.net.MalformedURLException exMalformedURLException) {
			exMalformedURLException.printStackTrace();
		} catch (java.io.IOException exIOException) {
			exIOException.printStackTrace();
		} finally {
			try {
				if (inputStream != null)
					inputStream.close();
				baos.close();
			} catch (IOException exIOException) {
				exIOException.printStackTrace();
			}
		}
		return fileData;
	}
	
}
@
